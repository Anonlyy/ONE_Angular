<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[前端性能优化之图片]]></title>
      <url>/2017/10/27/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<h2 id="图片优化的必要性"><a href="#图片优化的必要性" class="headerlink" title="图片优化的必要性"></a>图片优化的必要性</h2><p>在我们前端优化的种种方案中,包括js、html、css文件的打包压缩合并到极致,我们节省的空间至多也就是几十K的大小,但是在图片领域能够优化的空间,往往能够达到几百k到几M的范畴,这对于一个页面而言,优化力度可是极大的.所以在前端优化中,图片的优化是至关重要的.</p>
<h2 id="图片格式认知"><a href="#图片格式认知" class="headerlink" title="图片格式认知"></a>图片格式认知</h2><p>目前在项目开发中常见的图片格式,包括有:</p>
<ul>
<li>jpg</li>
<li>png</li>
<li>gif</li>
<li>svg</li>
<li>WebP</li>
</ul>
<h3 id="jpg格式"><a href="#jpg格式" class="headerlink" title="jpg格式"></a>jpg格式</h3><p><code>jpg</code> 全称叫做<code>jpeg</code>,<code>.jpg</code>和<code>.jpeg</code>这两种扩展名的实质是相同的，但因为DOS时代的8.3文件名命名原则是:拓展名不能超过三位,所以直接用作<code>.jpg</code>,虽然现在windows也可以支持任意长度的扩展名了，但大家已经习惯了.jpg的叫法，因此也就没有强制修正.</p>
<h4 id="baseline-jpeg"><a href="#baseline-jpeg" class="headerlink" title="baseline-jpeg"></a>baseline-jpeg</h4><h4 id="preogressive-jpeg"><a href="#preogressive-jpeg" class="headerlink" title="preogressive-jpeg"></a>preogressive-jpeg</h4><p><img src="http://7tszky.com1.z0.glb.clouddn.com/Fo8q3huYFyQma_rsSvo28dUyd7mN" alt=""><br>jpeg优势： 非常通用，图片更小<br>jpeg劣势： 图片色彩不够丰富,且不支持透明.</p>
<h3 id="PNG格式"><a href="#PNG格式" class="headerlink" title="PNG格式"></a>PNG格式</h3><p><code>PNG</code>,可移植网络图形格式,这种类型的图片可以展示 256 种颜色，而且每一种颜色都可以做成透明,所以这类图片我们常用来做透明和半透明的素材,缺点则是体积较大.</p>
<h3 id="GIF格式"><a href="#GIF格式" class="headerlink" title="GIF格式"></a>GIF格式</h3><p><code>GIF</code>,一般都理解为gif动画,其实<code>GIF</code>也可以存储图片,同时也支持透明,但作为图片,<code>GIF</code>只支持透明和不透明,不支持半透明,而且相对于<code>png</code>的图片,<code>GIF</code>的占用空间更大,它的唯一优势在于它是支持动画,而其他格式都不支持,所以一般我们图片是不使用<code>GIF</code>格式,只有在用动画的情况才使用。</p>
<h3 id="svg格式"><a href="#svg格式" class="headerlink" title="svg格式"></a>svg格式</h3><p>可缩放矢量图形，属于 XML 格式，百度地图就是使用 svg 绘制的，位图当你放大时单位面积内可视的像素点会变少，所以会失真，也就是我们常说的图片模糊，首先 svg 它是一个可以进行计算矢量图，放大和缩小的时每一个像素会根据向量重新计算，不会失真，并且 svg 的体积很小。</p>
<h3 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h3><p>是 Google 于2010年提出了一种新的图片压缩格式，<code>WebP</code> 为网络图片提供了无损和有损压缩能力，同时在有损条件下支持透明通道；无损 <code>WebP</code> 相比 <code>PNG</code> 减少26%大小，有损 <code>WebP</code> 在相同的结构相似性下相比 <code>JPEG</code> 减少 25%~34% 的大小，所以它也同时具备 <code>jpg</code> 和 <code>png</code> 的优点。<br>简单来说就是,体积比<code>jpeg</code>更小,而且还支持透明和半透明,渲染速度更快。<br>但在兼容性上只支持Chrome(29+)、Opera、和Android Brower,firefox和safari都不支持.<br><img src="http://static.zybuluo.com/jasminecjc/z1ik03y2es81x990qq35hutz/1.png" alt=""></p>
<h3 id="图片使用"><a href="#图片使用" class="headerlink" title="图片使用"></a>图片使用</h3><p>说着这么多的图片类型，我们在项目开发中，如何基于性能和用户体验的权衡来选择合适的图片类型呢？</p>
<p>如果是颜色丰富的图片，jpg 是通用的选择。<br>如果是较通用的动画，gif 是唯一可用的选择。<br>如果需要清晰的显示颜色丰富和透明的图片，png 是比较好的选择。<br>如果是企业级应用（不考虑兼容性），可以选择 WebP。</p>
<h3 id="目前比较流行的做法"><a href="#目前比较流行的做法" class="headerlink" title="目前比较流行的做法"></a>目前比较流行的做法</h3><h4 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h4><p><img src="http://zhitu.tencent.com/" alt="">、<img src="https://kraken.io/" alt=""></p>
<h4 id="CSS-Sprites-雪碧图"><a href="#CSS-Sprites-雪碧图" class="headerlink" title="CSS Sprites(雪碧图)"></a>CSS Sprites(雪碧图)</h4><h4 id="使用base64编码代替图片"><a href="#使用base64编码代替图片" class="headerlink" title="使用base64编码代替图片"></a>使用base64编码代替图片</h4><h4 id="iconfont、CSS3"><a href="#iconfont、CSS3" class="headerlink" title="iconfont、CSS3"></a>iconfont、CSS3</h4><h4 id="响应式动态图片加载"><a href="#响应式动态图片加载" class="headerlink" title="响应式动态图片加载"></a>响应式动态图片加载</h4><p><strong>场景</strong>：不同终端对同一个图片需求不一样，可以根据终端加载不同的图片来节省没必要的流量<br><strong>原理</strong>：通过picture元素，picturefill或平台判断来为不同终端平台输出不同的图片<br><strong>优势</strong>：减少没必要的图片加载，灵活控制，慢速用户加载小图片不至于加载失败，移动端没必要加载大尺寸图片等，可以通过不同方式兼容所有浏览器<br><strong>劣势</strong>：无法避免图片的加载过程，图片本身没优化</p>
<p><a href="http://imweb.io/topic/568b20194c44bcc56092e415" target="_blank" rel="external">http://imweb.io/topic/568b20194c44bcc56092e415</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Virtual DOM原理概述]]></title>
      <url>/2017/10/24/VirtualDOM%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p><img src="http://it.dyg.cn/wp-content/uploads/2017/10/timg-2.jpg" alt="Virtual DOM"></p>
<h2 id="Virtual-DOM概念的诞生"><a href="#Virtual-DOM概念的诞生" class="headerlink" title="Virtual DOM概念的诞生"></a>Virtual DOM概念的诞生</h2><p>先来说说<code>Virtual DOM</code>的起源,<code>Virtual DOM</code>的概念最早是在<code>React中</code>被提出来的,<a href="http://www.xposean.xin/2017/10/24/%E5%BD%B1%E5%93%8D%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%83%E5%87%B6-DOM%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">上一节</a>我们也说了,<code>DOM</code>操作是十分耗费性能,因为动不动操作就会引发回流，即渲染整个DOM树,对于移动端浏览器或者是复杂的页面来讲,这简直就是噩梦。</p>
<p>于是,聪明的工程师们就发明了一种<code>MVVM</code>模式,即视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。只要在模版中声明视图组件是和什么状态进行绑定的，通过改变状态，双向绑定引擎就会在状态更新的时候自动更新视图。</p>
<p>MVVM模式让我们大大减少代码中的DOM操作次数，其次可以提高<code>DOM</code>的渲染性能,因为他是通过模板引擎和JS构建修改DOM的,很大程度的减少了回流产生的次数。<br><img src="http://it.dyg.cn/wp-content/uploads/2017/10/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171022220758.png" alt=""></p>
<p>相对于 <code>DOM</code> 对象，原生的 <code>JavaScript</code> 对象处理起来更快，而且更简单。<code>DOM</code> 树上的结构、属性信息我们都可以很容易地用 <code>JavaScript</code> 对象表示出来。</p>
<p>但是它同时也存在什么问题呢?</p>
<p>那就是一旦我们所绑定的某一个状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧  的视图。</p>
<p>这样的做法会导致很多的问题。最大的问题就是这样做还是会很慢，因为即使一个小小的状态变更都要重新构造整棵 <code>DOM</code>，性价比太低；最后的结论会是：对于局部的小视图的更新，没有问题；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。</p>
<p><code>AngularJS</code>就是使用这个方式。</p>
<p>那么工程师经过改进呢,就发明了<code>Virtual DOM</code>啦!</p>
<h2 id="Virtual-DOM凭什么更加优秀"><a href="#Virtual-DOM凭什么更加优秀" class="headerlink" title="Virtual DOM凭什么更加优秀?"></a>Virtual DOM凭什么更加优秀?</h2><p>其实 <code>Virtual DOM</code> 跟MVVM模式是基本类似的，只是加了一些特别的步骤(diff)来避免了整棵 <code>DOM</code> 树变更。<br><img src="http://it.dyg.cn/wp-content/uploads/2017/10/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171022220758-1.png" alt=""></p>
<p><img src="https://camo.githubusercontent.com/a32766a14f6b7fbe631475ed1a186fbd9de7f2c3/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f7669727475616c2d646f6d2f636f6d706172652d696e2d6c6576656c2e706e67" alt=""></p>
<h3 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面:"></a>性能方面:</h3><ol>
<li><p>用JS构建虚拟DOM树,再通过虚拟DOM构建真正的DOM,这种方式性能快的多。</p>
</li>
<li><p>如果我们直接调用像.getElementById的方法,在复杂DOM的页面上,是十分耗费性能的,而在这只需要操作对应的JS对象即可。</p>
</li>
<li>比较两棵虚拟DOM树的不同,在真正的DOM元素上进行最小化修改(模板引擎).</li>
</ol>
<h3 id="代码方面"><a href="#代码方面" class="headerlink" title="代码方面:"></a>代码方面:</h3><ol>
<li>MVVM模式下,也使我们无需关注DOM元素,直接操作DOM元素对应的状态就行,对于代码编辑更好。</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[影响前端性能的元凶:DOM操作]]></title>
      <url>/2017/10/24/%E5%BD%B1%E5%93%8D%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%83%E5%87%B6-DOM%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>今天我们来谈谈影响前端性能的主要元凶:<strong>DOM操作.</strong></p>
<h2 id="重视DOM操作的原因"><a href="#重视DOM操作的原因" class="headerlink" title="重视DOM操作的原因?"></a>重视DOM操作的原因?</h2><p>在<strong>PC浏览器</strong>的时代,一般的小批量重绘或回流是感觉不出浏览器卡顿的,这主要是因为PC端的浏览器性能强而且网速够快,但到了如今我们的<strong>移动浏览器</strong>时代,轻微的DOM操作,在我们性能稍弱,网速不够快的移动浏览器上,影响性能的表现就会很明显了。</p>
<h2 id="DOM操作为什么会影响性能"><a href="#DOM操作为什么会影响性能" class="headerlink" title="DOM操作为什么会影响性能"></a>DOM操作为什么会影响性能</h2><p>在浏览器中，<code>DOM</code>的实现和<code>ECMAScript</code>的实现是分离的。所以通过<code>JavaScript</code>代码调用DOM接 口，相当于两个独立模块的交互。相比较在同一模块中的调用，这种跨模块的调用其性能损耗是很高的。但<code>DOM</code>操作对性能影响最大其实还是因为它导致了浏览器 的<strong>重绘</strong>和<strong>回流</strong>。</p>
<p><strong>重绘</strong>（repaint）:当前元素的颜色样式(背景颜色、字体颜色等)发生改变的时候，我们只需要把改变的元素重新的渲染一下即可，重绘主要改变外观风格（改个颜色，换个皮肤），不改变布局，不影响其他的dom。</p>
<p><strong>回流</strong>（reflow）:指浏览器为了重新渲染部分或者全部的文档而重新计算文档中元素的位置和几何构造的过程。如<code>DOM</code>元素的增删、位置移动、尺寸大小的改变以及浏览器窗口尺寸改变。每个页面至少会有一次回流,就是在页面初次渲染的时候。</p>
<p>这其中,重绘对浏览器的性能影响较小,一般不做优化，但是能避免最好.主要是回流需要尽可能避免和优化。</p>
<h2 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="headerlink" title="浏览器的渲染原理"></a>浏览器的渲染原理</h2><p>在渲染页面的过程中，浏览器会通过解析HTML文档来构建DOM树，解析<code>CSS</code>产生<code>CSS</code>规则树。<code>JavaScript</code>代码在解析过程中， 可能会修改生成的<code>DOM树</code>和<code>CSS</code>规则树。之后根据<code>DOM</code>树和<code>CSS</code>规则树构建渲染树，在这个过程中<code>CSS</code>会根据选择器匹配HTML元素。渲染树包括了每 个元素的大小、边距等样式属性，渲染树中不包含隐藏元素及<code>head</code>元素等不可见元素。最后浏览器根据元素的坐标和大小来计算每个元素的位置，并绘制这些元 素到页面上。重绘指的是页面的某些部分要重新绘制，比如颜色或背景色的修改，元素的位置和尺寸并没用改变；回流则是元素的位置或尺寸发生了改变，浏览器需 要重新计算渲染树，导致渲染树的一部分或全部发生变化。渲染树重新建立后，浏览器会重新绘制页面上受影响的元素。<br><img src="http://it.dyg.cn/wp-content/uploads/2017/10/snipaste_20171013_112243.png" alt=""></p>
<p>这就是DOM树<br><img src="http://it.dyg.cn/wp-content/uploads/2017/10/w_800-750x334.png" alt="DOM树"></p>
<p><strong>回流</strong>的代价比<strong>重绘</strong>的代价高很多，重绘会影响部分的元素，而回流则有可能影响全部的元素。</p>
<blockquote>
<p>注意：回流必将引起重绘，而重绘不一定会引起回流。</p>
</blockquote>
<h2 id="那我们怎样优化和避免重绘和回流"><a href="#那我们怎样优化和避免重绘和回流" class="headerlink" title="那我们怎样优化和避免重绘和回流?"></a>那我们怎样优化和避免重绘和回流?</h2><h3 id="1-合并多次的DOM操作为单次的DOM操作"><a href="#1-合并多次的DOM操作为单次的DOM操作" class="headerlink" title="1. 合并多次的DOM操作为单次的DOM操作"></a>1. 合并多次的DOM操作为单次的DOM操作</h3><pre><code>var element = document.getElementById(&apos;content&apos;);
//多次的DOM操作
element.style.borderColor = &apos;white&apos;;
element.style.borderStyle = &apos;solid&apos;;
element.style.borderWidth = &apos;1px&apos;;
//优化方案:1.可合并为一次
element.style.cssText += &apos;border: 1px solid white;background-color:green;&apos;;
//2.添加className
element.className += &apos;empty&apos;;
</code></pre><h3 id="2-把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上"><a href="#2-把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上" class="headerlink" title="2.把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上"></a>2.把DOM元素隐藏后修改、动画效果应用到position属性为absolute或fixed的元素上</h3><p>把DOM元素从页面流中脱离或隐藏，这样处理后，只会在DOM元素脱离和添加时，或者是隐藏和显示时才会造成页面的重绘或回流，对脱离了页面布局流的DOM元素操作就不会导致页面的性能问题。这种方式适合那些需要大批量修改DOM元素的情况。</p>
<pre><code>var myElement = document.getElementById(&apos;content&apos;);
myElement.style.display = &apos;none&apos;;
// 一些基于myElement的大量DOM操作
...
myElement.style.display = &apos;block&apos;;
</code></pre><h3 id="3-克隆DOM元素到内存中"><a href="#3-克隆DOM元素到内存中" class="headerlink" title="3.克隆DOM元素到内存中"></a>3.克隆DOM元素到内存中</h3><p>这种方式是把页面上的DOM元素克隆一份到内存中，然后再在内存中操作克隆的元素，操作完成后使用此克隆元素替换页面中原来的DOM元素。这样一来，<strong>影响性能的操作就只是最后替换元素的这一步操作了，在内存中操作克隆元素不会引起页面上的性能损耗</strong>。</p>
<pre><code>var old = document.getElementById(&apos;content&apos;);
var newElement= old.cloneNode(true); //复制DOM元素到内存中
// 一些基于clone的大量DOM 操作
...
//替换原来DOM元素
old.parentNode.replaceChild(newElement, old);
</code></pre><h3 id="4-使用JS模板引擎"><a href="#4-使用JS模板引擎" class="headerlink" title="4.使用JS模板引擎"></a>4.使用JS模板引擎</h3><p>在大批量的<code>DOM</code>元素操作,其实最方便或最有效的操作,应该是使用JS模板引擎,例如有<code>artTemplate</code>、<code>Mustache</code>等</p>
<h3 id="5-使用Virtual-DOM"><a href="#5-使用Virtual-DOM" class="headerlink" title="5.使用Virtual DOM."></a>5.使用Virtual DOM.</h3><p>这也是目前主流的前端框架(<code>Reac</code>t、<code>Vue</code>、<code>Angular</code>)所使用的方式,将会在<a href="http://www.xposean.xin/2017/10/24/VirtualDOM%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/" target="_blank" rel="external">下一节</a>详细讲述。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery的插件机制]]></title>
      <url>/2017/10/24/jQuery%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="jQuery框架现况分析和概述"><a href="#jQuery框架现况分析和概述" class="headerlink" title="jQuery框架现况分析和概述"></a>jQuery框架现况分析和概述</h2><p><img src="http://it.dyg.cn/wp-content/uploads/2017/09/151009222057-15-1-300x207.png" alt=""><br>虽然jQuery的市场占有率正逐年下滑,但不可避免的,jQuery仍是目前前端领域里使用率最高的前端框架,仍旧需要深入学习它,利用它更方便的写出优秀的前端代码。</p>
<p>先来回顾一下,jQuery的优秀之处:</p>
<ol>
<li>强大的DOM选择器</li>
<li>可靠的事件处理器</li>
<li>完善的Ajax函数</li>
<li>链式操作</li>
<li>出色的浏览器兼容性</li>
<li>强大的插件支持</li>
</ol>
<p>而本篇文章主要讲解的就是<code>jQuery</code>框架强大的<strong>插件系统</strong>支持,且听我慢慢道来.</p>
<h2 id="jQuery的插件系统概述"><a href="#jQuery的插件系统概述" class="headerlink" title="jQuery的插件系统概述"></a>jQuery的插件系统概述</h2><p>首先编写插件的目的很明确,就是为了能够让代码的<strong>复用性更强</strong>,<strong>提高可维护性和开发效率</strong>。</p>
<p>那首先,<code>jquery</code>的插件主要分为三种类型:</p>
<h3 id="封装对象方法的插件"><a href="#封装对象方法的插件" class="headerlink" title="封装对象方法的插件"></a>封装对象方法的插件</h3><p>这种是将对象方法封装起来,用于对通过选择器获得JQuery对象进行操作,也是最常用的插件类型。</p>
<p>简单的举例就是我们在<code>jQuery</code>用的<code>addClass()</code>、<code>parent()</code>此类的方法都是属于这种类型的插件。</p>
<h3 id="封装全局函数的插件"><a href="#封装全局函数的插件" class="headerlink" title="封装全局函数的插件"></a>封装全局函数的插件</h3><p>可以将独立的函数(方法)加到JQuey命名空间下.例如<code>jQuery</code>中的<code>$.Ajax()</code>和<code>$.trim()</code>这种就属于<code>jquery</code>编写的作为全局函数使用的插件。</p>
<h3 id="选择器插件"><a href="#选择器插件" class="headerlink" title="选择器插件"></a>选择器插件</h3><p>这个就很好理解了,虽然我们的Jquery的选择器非常的强大且丰富,但仍不是尽善尽美的,仍然有时候需要扩展一些我们自定义的选择器。</p>
<p><strong>注意事项:</strong><br>为了防止我们内部编写的变量影响到全局空间,我们在编写插件的时候必须通过一段代码来包裹我们的编写的代码体。</p>
<pre><code>;(function($){
    /* 放置我们的插件代码,并且可以通过$来作为JQuery的缩写别名*/
})(jQuery);
</code></pre><p>这样的话,我们写的插件里的变量不会污染到全局空间,而且我们在代码中还能继续使用过$来作为<code>jQuery</code>的缩写别名.</p>
<h2 id="JQuery的插件机制"><a href="#JQuery的插件机制" class="headerlink" title="JQuery的插件机制"></a>JQuery的插件机制</h2><p>简单介绍了<code>jQuery</code>插件以及其类型,我们再来讲讲<code>jQuery</code>的插件机制,<code>jQuery</code>是用什么来创建我们的插件的呢？</p>
<p><code>jQuery</code>提供了两个用于扩展<code>JQuery</code>功能的方法,即<code>jQuery.fn.extend(</code>)和<code>jQuery.extend()</code>方法。</p>
<p><code>jQuery.fn.extend()</code>用来扩展我们前面提到的第一种类型的插件,</p>
<p><code>jQuery.extend()</code>用来扩展第二和第三类型的插件。</p>
<p>这两个方法都接受一个<code>Object</code>类型的参数。</p>
<h2 id="编写jQuery插件"><a href="#编写jQuery插件" class="headerlink" title="编写jQuery插件"></a>编写jQuery插件</h2><h3 id="封装JQuery对象方法的插件"><a href="#封装JQuery对象方法的插件" class="headerlink" title="封装JQuery对象方法的插件"></a>封装JQuery对象方法的插件</h3><p>在这里我们要编写一个能够设置对象颜色的插件。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
    &lt;script class=&quot;jquer&quot; src=&quot;/js/sandbox/jquery/jquery-1.8.2.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;title&gt;演示代码&lt;/title&gt;
  &lt;/head&gt;
&lt;body&gt;
    &lt;div class=&apos;content&apos;&gt;hello&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;script&gt;
;(function($){
  jQuery.fn.extend({
    &quot;color&quot;:function(value){
      return this.css(&apos;color&apos;,value);
    }
  })
})(jQuery);

$(function(){
  $(&apos;.content&apos;).color(&apos;red&apos;);
});
&lt;/script&gt;
</code></pre><p>在这段代码中,我们通过<code>$.fn.extend()</code>就能够封装一个JQ对象的插件函数了。</p>
<p>通过<code>$(&#39;xxx&#39;).color(&#39;color&#39;)</code>,我们就能直接给DOM元素设置颜色了,极其方便好用。</p>
<h3 id="封装全局函数的插件-1"><a href="#封装全局函数的插件-1" class="headerlink" title="封装全局函数的插件"></a>封装全局函数的插件</h3><p>同样的我们可以编写一个能够清除去除左侧空格的插件函数。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;
  &lt;title&gt;JS Bin&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script src=&quot;https://code.jquery.com/jquery-2.2.4.js&quot;&gt;&lt;/script&gt;
  &lt;div class=&quot;content1&quot;&gt;

  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;script&gt;
;(function($){
    $.extend({
        ltrim:function(text){
            return (text||&quot;&quot;).replace(/^\s+/g,&quot;&quot;);
        }
    });
})(jQuery);
$(function(){
    var str = &quot;           2222&quot;;
    alert($.ltrim(str));
});
&lt;/script&gt;
</code></pre><p>在这段代码里,我们定义了一个全局函数的插件,来实现去除字符串左侧空格的功能,通过<code>$.extend()</code>设置后,我们就可以直接通过<code>$.ltrim(xxx)</code>来设置了。</p>
<h3 id="封装自定义选择器"><a href="#封装自定义选择器" class="headerlink" title="封装自定义选择器"></a>封装自定义选择器</h3><p>首先,我们以自带的选择器例子来做介绍:</p>
<pre><code>$(&quot;div:gt(1)&quot;)
</code></pre><p>这个例子中,选择器会首先找到所有div的元素,再遍历这些元素,然后将这些元素和”1″和下标一起传入gt选择器对应的选择器函数中。根据函数里编写的代码,如若返回true,则该元素会保留,反之,该元素就会被忽略。</p>
<p>而例子中的gt选择器函数转化成自定义的<strong>选择器函数</strong>是这样的:</p>
<pre><code>function(a,i,m){
  return i&gt;m[3]-0;
}
</code></pre><p>第一个参数a:指的是当前遍历的DOM元素;</p>
<p>第二个参数i:指的是当前遍历的DOM元素的索引值,从0开始;</p>
<p>第三个参数m:他是由JQuery解析出来的一个数组.<br><img src="http://it.dyg.cn/wp-content/uploads/2017/09/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170910170144.png" alt=""></p>
<p>介绍完这些,接下来我们来自己编写一个自定义的选择器:</p>
<p>创建一个根据你传入的字符串等于DOM元素文本内容的选择器:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;
  &lt;title&gt;JS Bin&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script src=&quot;https://code.jquery.com/jquery-2.2.4.js&quot;&gt;&lt;/script&gt;
  &lt;p&gt;111&lt;/p&gt;
  &lt;p&gt;222&lt;/p&gt;
  &lt;p&gt;333&lt;/p&gt;
  &lt;p&gt;444&lt;/p&gt;
  &lt;p&gt;555&lt;/p&gt;
  &lt;p&gt;666&lt;/p&gt;
  &lt;p&gt;777&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;script&gt;
;(function($){
  $.extend($.expr[&quot;:&quot;],{
    &quot;equal&quot;: function(a,i,m){
      return $(a).text()==m[3];
    }
  });
})(jQuery);
$(function(){
  $(&apos;p:equal(111)&apos;).css(&apos;color&apos;,&quot;red&quot;);
});
&lt;/script&gt;
</code></pre><p>该选择器会根据传入的字符找到字符相等的元素。</p>
<p>因为选择器函数是属于调用<strong>十分频繁</strong>的函数,所以在编写的时候,一定要秉承优化再优化的原则,不能草草了事。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是jQuery的插件系统,利用好插件,可以给我们的开发工作带来十分大的效率提升。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[移动web适配方案简述]]></title>
      <url>/2017/10/24/%E7%A7%BB%E5%8A%A8web%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E7%AE%80%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p>众所周知,目前移动设备的访问量早已超越PC端设备,这就意味着用户使用移动设备访问页面的行为越发频繁,这就给web前端开发人员带来了一系列的苦恼,如何才能在不同大小的设备上呈现同样的网页？这是每一个移动web开发者的都会发出的疑问.接下来,本文将讲述自适应网页设计的概念和方法，使网页开发人员维护同一个网页代码，即可使网站在多种设备上具有更好的阅读体验。</p>
<blockquote>
<p>本文详细介绍了网页全适配的实现方法，希望能给迷惑的你带来帮助。</p>
</blockquote>
<h2 id="先说说方案"><a href="#先说说方案" class="headerlink" title="先说说方案"></a>先说说方案</h2><p>目前主流的方案有两个,<strong>响应式</strong>以及<strong>自适应</strong>的解决方案,除此之外也有其他的方案,但在这主要只讲这两者.<br><img src="http://it.dyg.cn/wp-content/uploads/2017/08/eb206edc273b0ac47a7da1f157010bad_r.png" alt=""><br><strong>自适应</strong>:在移动端设备上浏览，网页与PC端无大的差别，原网页的布局在任何设备上都可以保持一致，不会因为屏幕窄宽大小而会影响视觉效果（不会被遮挡）和响应效果。<br><strong>响应式</strong>:在手机等设备上浏览，网页与PC端内容相似，但布局是自动改变为专为手机等其他设备所准备的。</p>
<h3 id="自适应方案"><a href="#自适应方案" class="headerlink" title="自适应方案"></a>自适应方案</h3><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/459873-20151014135809710-1472399325.png" alt=""></p>
<p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/459873-20151014135813913-563846656.png" alt=""></p>
<p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/459873-20151014135815319-1600880598.png" alt=""></p>
<p>拉勾网和简书网的页面就属于是自适应方案,这种页面有以下特别:</p>
<p>1.文字流式;</p>
<p>2.控件弹性</p>
<p>3.图片等比缩放</p>
<p>4.顶部或底部的的bar无论宽度怎么变,高度和位置不变.</p>
<p>但自适应布局更多用在页面元素相对没那么复杂的网站,如果是比较复杂的网站,并不推荐使用这个布局,简单的说，图片为主内容的可以用自适应布局,例如花瓣网这种.</p>
<hr>
<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>目前一般常见的实现响应式有两种方法，一种是利用<strong>媒体查询</strong>，另外一种利用<strong>JS计算屏幕宽度做出响应</strong>.</p>
<p>但从性能和易用程度上,推荐使用媒体查询,媒体查询可以针对不同的屏幕尺寸设置不同的样式,对于响应式布局的页面,非常有用.</p>
<p>bootstrap的 <strong>栅格布局</strong> 就是根据这种原理实现的。</p>
<h4 id="当页面宽度大于1200px"><a href="#当页面宽度大于1200px" class="headerlink" title="当页面宽度大于1200px:"></a>当页面宽度大于1200px:</h4><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/snipaste_20170814_210916-750x425.png" alt=""></p>
<hr>
<h4 id="当页面宽度大于900px并且小于1200px"><a href="#当页面宽度大于900px并且小于1200px" class="headerlink" title="当页面宽度大于900px并且小于1200px:"></a>当页面宽度大于900px并且小于1200px:</h4><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/snipaste_20170814_210928-300x226.png" alt=""></p>
<hr>
<h4 id="当页面宽度小于900px"><a href="#当页面宽度小于900px" class="headerlink" title="当页面宽度小于900px:"></a>当页面宽度小于900px:</h4><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/snipaste_20170814_210940-182x300.png" alt=""></p>
<hr>
<p>但这种布局,会存在一个问题,那就是元素字体、间距、宽高等属性的属性值不会随着屏幕的宽度进行放大或缩小,这个时候,就得动态改变我们的css单位了.</p>
<h4 id="em相对单位"><a href="#em相对单位" class="headerlink" title="em相对单位"></a>em相对单位</h4><p>em的特点 : 1. em的值并不是固定的; 2.em始终会继承父级元素的字体大小。</p>
<p>但因为em在易用性上不强,且父级元素继承关系容易紊乱,所以又推出了rem单位.</p>
<h4 id="rem相对单位"><a href="#rem相对单位" class="headerlink" title="rem相对单位"></a>rem相对单位</h4><p>rem也是相对单位,但它是基于根元素(也就是html标签)做相对大小,这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应.</p>
<h4 id="Js动态设置rem来实现移动端字体的自适应"><a href="#Js动态设置rem来实现移动端字体的自适应" class="headerlink" title="Js动态设置rem来实现移动端字体的自适应"></a>Js动态设置rem来实现移动端字体的自适应</h4><p>原理就是:利用Js获取设备屏幕的宽度，并根据屏幕的宽度动态改变根元素html的font-size属性的作用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果在不考虑人力成本和时间成本的话,只考虑页面效果,首推PC端和移动端各自两套页面布局,这样方案是最合适;甚至可以移动端自适应布局,pc端响应式布局.</p>
<p>例如我们<a href="http://www.dyg.cn" target="_blank" rel="external">东阳光商城</a>,就是两套布局方案.</p>
<p>以及百度、淘宝、知乎,这些大型的网站都是这样,主要还是因为考虑到业务等各方面的原因.</p>
<p>因为虽然响应式和自适应能够达到我们的效果,但在细节之处总是不够尽如人意,同时在页面布局上是固定几个模板的,不能更加的别出心栽和创意.</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[来聊聊localStorage、sessionStorage和cookie]]></title>
      <url>/2017/10/24/%E6%9D%A5%E8%81%8A%E8%81%8AlocalStorage%E3%80%81sessionStorage%E5%92%8Ccookie/</url>
      <content type="html"><![CDATA[<p>首先当然还得是来介绍一下基本概念.</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>对于<code>Cookie</code>,不用介绍的太多,想必大家也都很熟悉了.<code>Cookie</code>实际上是一小段的文本信息,每个Cookie的大小限制为4KB.</p>
<p>它的主要用途有保存登录信息，比如你登录某个网站市场可以看到浏览器提醒你需要“记住密码”，这通常就是通过在 <code>Cookie</code> 中存入一段辨别用户身份的数据来实现的。</p>
<h3 id="web-Storage"><a href="#web-Storage" class="headerlink" title="web Storage"></a>web Storage</h3><p><code>sessionStorage</code> 和 <code>localStorage</code> 是<strong>HTML5 Web Storage API</strong> 提供的，可以方便的在<code>web</code>请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</p>
<p>在这之前,客户端存储数据都是使用cookie,但是大家都知道,每一次HTTP请求,都会带着cookie给后端,即使是不需要传输的情况下,这在无形之中就增加带宽的浪费,而<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p>
<h3 id="三者的异同"><a href="#三者的异同" class="headerlink" title="三者的异同"></a>三者的异同</h3><p><img src="http://it.dyg.cn/wp-content/uploads/2017/08/Snipaste_2017-08-05_21-13-28.png" alt=""></p>
<p><strong>通过上图的表,大概总结一下webstorage API的好处:</strong><br>1.<strong> 减少网络流量</strong>：一旦数据保存在本地后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要地来回传递。</p>
<ol>
<li><strong>快速显示数据</strong>：性能好，从本地读数据比通过网络从服务器获得数据快得多，本地数据可以即时获得。再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示。<br>3.<strong> 临时存储</strong>：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用<code>sessionStorage</code>非常方便。</li>
<li><strong>更多丰富易用的接口</strong>：<code>Web Storage</code>提供了一套更为丰富的接口，使得数据操作更为简便。</li>
</ol>
<h2 id="Webstorage-API的简单使用"><a href="#Webstorage-API的简单使用" class="headerlink" title="Webstorage API的简单使用"></a>Webstorage API的简单使用</h2><pre><code>//创建localStorage对象
var localstroage = window.localStorage;  
//存储值
localstroage.setItem(&apos;name&apos;,&apos;Jack&apos;);  
localstroage.setItem(&apos;uid&apos;,&apos;10001&apos;);  
//获取值
var openid = localstroage.getItem(&apos;openid&apos;);  
console.log(openid);
//删除值
localstroage.removeItem(&apos;openid&apos;);  
//清空值
localstroage.clear(); 
</code></pre><p>而<code>sessionStorage</code>的使用则与<code>localStorage</code>完全一致.</p>
<p>此外,HTML5在提供了<code>storage</code>事件,当键值改变或者clear的时候，就可以触发<code>storage</code>事件,相当于加了个监听事件,这也是<code>cookie</code>原生没有的.</p>
<p>##应用场景和总结</p>
<p>我们的Storage API,可以用在<strong>IM聊天记录</strong>,<strong>购物车</strong>,<strong>HTML5的游戏数据存储</strong>,<strong>内容多的表单</strong>.<br>并非说有了<code>localStorage</code>、<code>sessionStorage</code>,<code>cookie</code>就会被淘汰了,就目前的客户端(浏览器)使用而言,<code>cookie</code>的使用率仍然是非常高的,只是在某种特定的情况下呢,使用我们的webStorageAPI会更加方便好用,更快的解决问题.</p>
<p>此外,我们的<code>webStorageAPI</code>也仍存在一些局限,一个是兼容性问题,是不支持IE8以下的,还有一个是如果用户使用的是浏览器的隐身模式的话,是无法访问用<code>localStorage</code>存储下来的值的。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Gulp入门]]></title>
      <url>/2017/10/24/Gulp%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="Gulp是啥子东西？"><a href="#Gulp是啥子东西？" class="headerlink" title="Gulp是啥子东西？"></a>Gulp是啥子东西？</h2><p><img src="http://www.d1net.com/uploadfile/2017/0112/20170112092834684.png" alt=""></p>
<p>一句话简单的概括,就是一个前端项目自动化的构建工具。不理解没关系,容我慢慢道来。</p>
<p>首先要说说<code>Gulp</code>诞生的原因.</p>
<p>随着 <code>Web</code> 前端发展，前端项目变得越来越复杂，随之而来的是各种方便的工具：打包工具、转码工具、 <code>JS</code> 与 <code>CSS</code> 的合并压缩工具等等。这些工具极大的提高了我们前端的代码质量，但问题也随之而来：</p>
<p>这么多工具到底该怎么使用，难道一个个在各个工具中来回切换复制粘贴？或是在 CLI 里一条条地敲命里吗？敲完代码还要敲一堆的构建命令，说不准顺序搞错了还要功亏一篑重来一遍？</p>
<p>于是我们的构建工具 <code>Gulp</code> 就应运而生啦。</p>
<h3 id="Gulp有啥好处？"><a href="#Gulp有啥好处？" class="headerlink" title="Gulp有啥好处？"></a>Gulp有啥好处？</h3><p>首先当然是省心省力啦,<strong>一次配置,自动构建</strong>.我把我需要的功能配置出来后,以后直接用<code>Gulp</code>调用就好了,Gulp会帮我整合好我需要的功能。</p>
<p>第二个就是重复利用啦,因为配置文件的高度统一，这个配置文件几乎可以多个项目之间随便复制粘贴修修改改就可以重复使用！</p>
<h2 id="Gulp能做什么"><a href="#Gulp能做什么" class="headerlink" title="Gulp能做什么"></a>Gulp能做什么</h2><p>当你按下 <code>ctrl+s</code> 时,你发现你的电脑自动帮你编译、压缩、打包、自动刷新。你会不会觉得很爽呢？</p>
<p>下面我来说说Gulp的常用功能。</p>
<ul>
<li>静态文件的合并与压缩:JS 、css、html的压缩</li>
<li>图片(包括PNG、JPEG、GIF和SVG图片)的压缩,在不降低画质的情况下,降低图片的大小。</li>
<li>页面自动刷新,你的代码有任何变动都会刷新。</li>
<li>还有一些CSS预编译器(sass、less),ES6语法,都可以自动编译成浏览器能够识别的。</li>
<li>图片路径转base64<br>等等….<br>而这些功能的实现在配置完后你只需要做什么, <code>ctrl+s</code> !!!</li>
</ul>
<h2 id="Gulp的运行和安装"><a href="#Gulp的运行和安装" class="headerlink" title="Gulp的运行和安装"></a>Gulp的运行和安装</h2><p>关于Gulp的环境配置和安装,可以直接点击<a href="http://www.ydcss.com/archives/18" target="_blank" rel="external">这里查看教程</a>。</p>
<p>看完之后,有两个配置文件是我们一定要重视的,一个是<strong>gulpfile.js</strong>,另一个是<strong>package.json</strong>.如果其他人想要复制你的 <code>gulp</code> 功能属性,这两个文件是必须必备的。</p>
<p><strong>package.json</strong>是基于<code>nodejs</code>项目必不可少的配置文件，它是存放在项目根目录的普通json文件,里面存放是项目的一些基本配置,以及你安装的所有gulp插件.</p>
<p>当我们已经把所有的配置都安装好了之后，我们需要在gulpfile.js文件里面写我们的任务(task),我们需要在什么时候用什么插件,都要写在这里。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Flex布局]]></title>
      <url>/2017/10/24/Flex%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<p>开篇我们先来看看传统的CSS布局格式,布局的传统解决方案：</p>
<p>基于盒状模型，依赖 <code>display</code> 属性 + <code>position</code>属性 + <code>float</code>属性。它对于那些特殊布局非常不方便，比如，垂直居中和绝对居中就很不容易实现。况且 <code>float</code> 用多了还得清除浮动.</p>
<h2 id="Flex是什么鬼"><a href="#Flex是什么鬼" class="headerlink" title="Flex是什么鬼?"></a>Flex是什么鬼?</h2><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt=""></p>
<p><code>Flex</code> 是 <code>Flexible Box</code> 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为 <code>Flex</code> 布局,只要加个 <code>display</code> 属性。<br>在这里先不考虑各浏览器的适配问题.在文末会提供解决方案。</p>
<p>注意，设为 <code>Flex</code> 布局以后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用 <code>Flex</code> 布局的元素，称为 <code>Flex</code> 容器（flex container），简称”<strong>容器</strong>“。它的所有子元素自动成为容器成员，称为 <code>Flex</code> 项目（flex item），简称”<strong>项目</strong>“。</p>
<p>通俗的说,就是<strong>容器</strong>是父元素,<strong>项目</strong>是子元素。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt=""></p>
<p>容器默认存在两根轴：水平的<strong>主轴</strong>（main axis）和垂直的<strong>交叉轴</strong>（cross axis）。其实就是<strong>横轴</strong>和<strong>纵轴</strong>。</p>
<h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><ul>
<li><code>flex-direction</code>(属性决定主轴的方向（即项目的排列方向))</li>
<li><code>flex-wrap</code>(<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。)</li>
<li><code>flex-flow</code>(<code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式)</li>
<li><code>justify-content</code>(定义了项目在主轴上的对齐方式)</li>
<li><code>align-items</code>(定义项目在交叉轴上如何对齐)</li>
<li><code>align-content</code>(<code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。)</li>
</ul>
<h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><ul>
<li><code>order</code>(性定义项目的排列顺序。数值越小，排列越靠前，默认为0。)</li>
<li><code>flex-grow</code>(属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。)</li>
<li><code>flex-shrink</code>(属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。)</li>
<li><code>flex-basis</code>(属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。)</li>
<li><code>flex</code>(是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为0 1 auto)</li>
<li><code>align-self</code>(属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性)</li>
</ul>
<p>关于 Flex 布局的语法基础就讲到这里，相信能看到这里你一定会有收获。</p>
<p>如果你看完还是一头雾水的话，没关系，可以看<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="兼容性与各浏览器差异性解决方案"><a href="#兼容性与各浏览器差异性解决方案" class="headerlink" title="兼容性与各浏览器差异性解决方案"></a>兼容性与各浏览器差异性解决方案</h2><p>通过<code>PostCSS</code>的<code>autoprefixer</code>插件,即能自动添加浏览器私有前缀,防止出现各大浏览器中展示效果不同的情况。</p>
<p>访问这篇文章<a href="http://www.xposean.xin/2017/10/24/PostCSS%E5%85%A5%E9%97%A8/" target="_blank" rel="external">《PostCSS入门》</a>。</p>
<p>如果不想麻烦使用<code>PostCSS</code>,也可以通过<code>gulp</code>安装<a href="http://www.ydcss.com/archives/94" target="_blank" rel="external">gulp-autoprefixer</a>插件,一样可以达到效果。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[PostCSS入门]]></title>
      <url>/2017/10/24/PostCSS%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我想你应该已经听说过<a href="http://postcss.com/" target="_blank" rel="external">PostCSS</a>,它比<a href="https://github.com/postcss/benchmark#preprocessors" target="_blank" rel="external">libsass</a>快了几乎两倍(并且比Ruby Sass快了28倍)； 或者听说过它支持<a href="http://cssnext.io/" target="_blank" rel="external">cssnext</a>和自动添加私有前缀而且可扩展功能,难道你一点都不好奇吗？</p>
<p>PostCSS最强大之处在于它是模块化并且基于插件的架构，不过这也是个缺点。如果你之前在项目中使用Sass(比如大多数的设计师和前端开发者)，你从不需要配置任何东西——Sass内置了全部实用功能，开箱即用。 然而，PostCSS需要你做一些配置。你不得不从一眼看不到底的<a href="https://github.com/postcss/postcss/blob/master/docs/plugins.md" target="_blank" rel="external">插件列表</a>选择插件并且自己把全部插件一起配置。但这同时意味着它的自定义程度高,足够实现你想要的。</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>PostCSS在以惊人的速度发展，而且越来越受人欢迎。越来越多的人开始在了解它，使用它。因为他们意识到，在项目中使用PostCSS让他们意识到了眼前一亮。</p>
<p><img src="http://www.w3cplus.com/sites/default/files/blogs/2015/1510/postcssdownloads.png" alt=""></p>
<p>2014年总共不到140万的下载量，但从2015年1月份到6月份已经超过380万个下载。</p>
<p><strong><a href="https://github.com/postcss/autoprefixer" target="_blank" rel="external">Autoprefixer</a></strong>是PostCSS中最流行的插件，其中Google、Shopify、Twitter、Bootstrap和Codepen都在使用这个插件。Wordpress也使用Autoprefixer插件，而且还使用RTLCSS插件。Alibaba使用了几个PostCSS插件，以及也参加PostCSS的开发。</p>
<h2 id="运行PostCSS"><a href="#运行PostCSS" class="headerlink" title="运行PostCSS"></a>运行PostCSS</h2><p>运行PostCSS的方法有很多种。你可以很容易地将它添加到Gulp、webpack的构建过程中；<br>或者是通过最简单的方式,即postcss-cli来构建都是OK的,但因为我是习惯使用gulp,所以接下来介绍的是通过gulp配置,如果想使用其他方式构建，请自行度娘或google。</p>
<p>在已经安装了gulp的配置环境下,我们直接开始进行postCSS的配置.</p>
<h3 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h3><p>首先在你的项目中创建两个文件夹，一个命名为src，另一个命名为dest。src文件夹用来放置未处理的CSS文件，而dest用来放置PostCSS插件处理后的文件。</p>
<p>接下来需要做的就是在你的项目中安装gulp-postcss插件，安装好之后就可以使用PostCSS处理器。</p>
<p>打开你的命令终端(CMD)，并且进入到你的项目根目录下，然后在命令终端输入下面的命令：</p>
<pre><code>npm install --save-dev gulp-postcss
</code></pre><p>安装完成后你的项目结构看起来就应该像这样：<br><img src="http://www.w3cplus.com/sites/default/files/blogs/2015/1510/gulpproject.png" alt=""></p>
<p>现在通过编辑器打开gulpfile.js文件，并且创建gulp和gulp-postcss变量，如下面代码所示：</p>
<pre><code>var gulp = require(&apos;gulp&apos;); 
var postcss = require(&apos;gulp-postcss&apos;);
</code></pre><p>那我们现在可以设置一个任务，让PostCSS读取CSS原文件并且处理它。</p>
<p>添加的代码如下：</p>
<pre><code>gulp.task(&apos;css&apos;, function () {
  var processors = [ ];
  return gulp.src(&apos;./src/*.css&apos;).pipe(postcss(processors)).pipe(gulp.dest(&apos;./dest&apos;)); 
});
</code></pre><p>我们一起来看一下上面的代码。在第一行，设置了一个任务名叫css。这个任务将会执行一个函数，同时在这个函数中创建了一个名为processors的数组。现在这个数组为空，这里将插入我们想使用的PostCSS插件。<br>在processors数组后面，我们指定了需要处理的目标文件，即src目录中的任何CSS文件。</p>
<p>这里面使用了两个.pipe()函数，设置postcss()执行PostCSS，并且给postcss()传递processors参数，后面会告诉PostCSS要使用哪个插件。</p>
<p>接下来的第二个.pipe()函数，指定结过PostCSS处理后的CSS放置在dest文件夹中。</p>
<h3 id="添加PostCSS插件"><a href="#添加PostCSS插件" class="headerlink" title="添加PostCSS插件"></a>添加PostCSS插件</h3><p>假设,现在我们添加需要的PostCSS插件：<strong>Autoprefixer</strong>(处理浏览器私有前缀)著作权归作者所有。<br>运行下面的命令，将插件安装到你的项目:</p>
<pre><code>npm install autoprefixer --save-dev
</code></pre><p>接下来，在我们的项目中定义变量，将这些插件加载到我们的项目中。和前面的方式一样，在<strong>gulpfile.js</strong>文件中添加下面的代码：</p>
<pre><code>var autoprefixer = require(&apos;autoprefixer&apos;);
</code></pre><p>然后将这个插件添加到processors数组中，更新后的数组如下：</p>
<pre><code>var processors = [ autoprefixer];
</code></pre><p>插件已经添加到了<code>processors</code>数组中了，这个时候<code>PostCSS</code>会知道将这些插件功能应用到我们的CSS源文件中。</p>
<h3 id="测试编译"><a href="#测试编译" class="headerlink" title="测试编译"></a>测试编译</h3><p>在src目录中创建一个测试文件style.css，并在这个文件中添加一些CSS的测试代码：</p>
<pre><code> /* Testing autoprefixer */ 
.autoprefixer { display: flex; }
</code></pre><p>在命令终端执行<code>gulp css</code>命令。在dest目录生成的文件会有下面的代码：</p>
<pre><code>/* Testing autoprefixer */ 
.autoprefixer { 
    display: -webkit-box;
    display: -webkit-flex;
    display: -ms-flexbox;
    display: flex; 
}
</code></pre><p>如上面编译出来的代码你应该看到了Autoprefixer给需要的属性添加了浏览器的私有前缀，编译符合需求的代码。</p>
<h4 id="设置插件选项"><a href="#设置插件选项" class="headerlink" title="设置插件选项"></a>设置插件选项</h4><p>注：每一个插件都有对应的配置参数选项，如果你想为一个插件配置选项参数，你可以在gulpfile.js文件中,在插件后面添加一对括号，并在里面传递选项的参数。例如，Autoprefixer需要指定对应的浏览器列表参数，你可以像这样设置：</p>
<pre><code>var processors = [ 
    autoprefixer({browsers: [&apos;last 1 version&apos;]})
];
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>通过<code>npm</code>(或<code>cnpm</code>)创建项目，并且将<code>gulp</code>安装到<code>gulpfile</code>文件</li>
<li>安装<code>gulp-postcss</code>插件</li>
<li>设置你的<code>gulpfile.js</code>文件，将<code>gulp</code>和<code>gulp-postcss</code>加载到项目中</li>
<li>创建一个任务，来编译你的<code>CSS</code></li>
<li>在任务中，设置一个<code>processors</code>数组</li>
<li>在<code>.pipe()</code>设置<code>一个postcss()</code>函数，并且将<code>processors</code>传递给它</li>
</ol>
<p>你可以根据上面的教程介绍，遵循相同的步骤，你可以将<code>PostCSS</code>任何插件安装到项目中。</p>
<p>通过<code>npm install &lt;plugin_name&gt; –save-dev</code> 命令将插件安装到你的项目中<br>类似<code>var autoprefixer = require(&quot;autoprefixer&quot;)</code>代码在你的<code>gulpfile.js</code>文件中定义要加载的插件变量名<br>将变量名添加到你的<code>preprocessors</code>数组中</p>
]]></content>
      
        
    </entry>
    
  
  
    
  
</search>
